import os
from pathlib import Path

import google.generativeai as genai

# import pandas as pd # No longer needed here
from dotenv import load_dotenv
from google.generativeai import types

# from sqlalchemy.engine import Engine # No longer needed here
from . import (
    ratings,
    storage,
)  # storage is still needed for store_chapter_text and append_fork (now imported from storage)

# load_dotenv() must be called after all imports for E402,
# but before any code that relies on the .env variables.
load_dotenv()

MODEL_NAME = "gemini-2.5-flash-preview-05-20"


def _gemini_request(prompt: str) -> str:
    """Return text generated by Gemini using the google-generativeai client."""
    load_dotenv()
    key = os.getenv("GEMINI_API_KEY")
    if not key:
        raise RuntimeError("GEMINI_API_KEY not set")

    client = genai.Client(api_key=key)
    contents = [types.Content(role="user", parts=[types.Part.from_text(text=prompt)])]
    cfg = types.GenerateContentConfig(
        safety_settings=[
            types.SafetySetting(category="HARM_CATEGORY_HARASSMENT", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_HATE_SPEECH", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_DANGEROUS_CONTENT", threshold="BLOCK_NONE"),
        ],
        response_mime_type="text/plain",
    )

    chunks = client.models.generate_content_stream(model=MODEL_NAME, contents=contents, config=cfg)
    return "".join(chunk.text for chunk in chunks)


def generate_chapter(prompt: str, prev_uuid: str | None = None) -> str:
    """Generate a chapter with Gemini and store it."""
    text = _gemini_request(prompt)
    return storage.store_chapter_text(text)


# append_fork has been moved to storage.py


def auto_vote(
    position: int, prev_uuid: str, voter: str # conn parameter removed
) -> str:
    """Generate winner and loser chapters, create forks, and record a vote using global DataManager."""
    winner_uuid = generate_chapter(f"Winner for position {position}", prev_uuid)
    loser_uuid = generate_chapter(f"Loser for position {position}", prev_uuid)

    # The concept of a specific 'fork_csv' for auto_vote is removed.
    # Forks are now added to the central in-memory DB.
    # storage.append_fork now uses the global DataManager session.
    # It also handles calculating the fork_uuid internally.
    storage.append_fork(
        position=position,
        prev_uuid=prev_uuid,
        uuid_str=winner_uuid
        # status="AUTO_GENERATED" # Could add a specific status if desired
    )
    storage.append_fork(
        position=position,
        prev_uuid=prev_uuid,
        uuid_str=loser_uuid
        # status="AUTO_GENERATED"
    )

    # ratings.record_vote will also need to be refactored to use the global DataManager.
    # For now, remove conn, assuming ratings.record_vote will be updated.
    ratings.record_vote(position, voter, winner_uuid, loser_uuid)
    return winner_uuid
