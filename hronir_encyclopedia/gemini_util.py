import os
from pathlib import Path

import pandas as pd
import google.generativeai as genai
from google.generativeai import types

from . import storage, ratings

MODEL_NAME = "gemini-2.5-flash-preview-05-20"


def _gemini_request(prompt: str) -> str:
    """Return text generated by Gemini using the google-generativeai client."""
    key = os.getenv("GEMINI_API_KEY")
    if not key:
        raise RuntimeError("GEMINI_API_KEY not set")

    client = genai.Client(api_key=key)
    contents = [
        types.Content(role="user", parts=[types.Part.from_text(text=prompt)])
    ]
    cfg = types.GenerateContentConfig(
        safety_settings=[
            types.SafetySetting(category="HARM_CATEGORY_HARASSMENT", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_HATE_SPEECH", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold="BLOCK_NONE"),
            types.SafetySetting(category="HARM_CATEGORY_DANGEROUS_CONTENT", threshold="BLOCK_NONE"),
        ],
        response_mime_type="text/plain",
    )

    chunks = client.models.generate_content_stream(
        model=MODEL_NAME, contents=contents, config=cfg
    )
    return "".join(chunk.text for chunk in chunks)


def generate_chapter(prompt: str, prev_uuid: str | None = None) -> str:
    """Generate a chapter with Gemini and store it."""
    text = _gemini_request(prompt)
    return storage.store_chapter_text(text, previous_uuid=prev_uuid)


def append_fork(csv_file: Path, position: int, prev_uuid: str, uuid: str) -> str:
    csv_file.parent.mkdir(parents=True, exist_ok=True)
    fork_uuid = storage.compute_forking_uuid(position, prev_uuid, uuid)
    if csv_file.exists():
        df = pd.read_csv(csv_file)
    else:
        df = pd.DataFrame(columns=["position", "prev_uuid", "uuid", "fork_uuid"])
    df = pd.concat([
        df,
        pd.DataFrame([{"position": position, "prev_uuid": prev_uuid, "uuid": uuid, "fork_uuid": fork_uuid}])
    ], ignore_index=True)
    df.to_csv(csv_file, index=False)
    return fork_uuid


def auto_vote(position: int, prev_uuid: str, voter: str) -> str:
    """Generate winner and loser chapters and record a vote."""
    winner_uuid = generate_chapter(f"Winner for position {position}", prev_uuid)
    loser_uuid = generate_chapter(f"Loser for position {position}", prev_uuid)
    fork_csv = Path("forking_path/auto.csv")
    append_fork(fork_csv, position, prev_uuid, winner_uuid)
    append_fork(fork_csv, position, prev_uuid, loser_uuid)
    ratings.record_vote(position, voter, winner_uuid, loser_uuid)
    return winner_uuid
